<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç¶œåˆæ°´æœæ‹¼ç›¤</title>
    <style>
        :root {
            --primary: #ff6b6b;
            --secondary: #4ecdc4;
            --bg: #f7f9fc;
            --tile: #fff;
            --text: #2d3436;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg);
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            color: var(--text);
        }

        /* --- é é¢åˆ‡æ›æ§åˆ¶ --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* é è¨­éš±è— */
            flex-direction: column;
            background: var(--bg);
            z-index: 1;
        }
        .screen.active {
            display: flex;
        }

        /* --- 1. åœ°åœ–é é¢æ¨£å¼ --- */
        #map-screen {
            align-items: center;
            overflow-y: auto;
            padding: 20px;
        }

        .map-header {
            text-align: center;
            margin-bottom: 30px;
        }
        .map-header h1 { font-size: 1.8rem; margin: 10px 0; color: var(--primary); }
        .map-header p { color: #888; font-size: 0.9rem; }

        .level-path {
            display: flex;
            flex-direction: column; /* ç›´å‘åœ°åœ– */
            align-items: center;
            gap: 25px;
            width: 100%;
            padding-bottom: 50px;
        }

        .level-node {
            width: 70px;
            height: 70px;
            background: #ddd;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            position: relative;
            cursor: pointer;
            box-shadow: 0 4px 0 #bbb;
            transition: transform 0.1s;
        }

        .level-node.unlocked {
            background: var(--secondary);
            box-shadow: 0 4px 0 #3b9e96;
        }

        .level-node.current {
            background: var(--primary);
            box-shadow: 0 4px 0 #c0392b;
            animation: pulse 1.5s infinite;
        }

        .level-node::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 25px;
            background: #ddd;
            top: 70px;
            z-index: -1;
        }
        .level-node:last-child::after { display: none; }
        
        /* ç´€éŒ„é¡¯ç¤º */
        .best-score {
            position: absolute;
            right: -80px;
            background: #fff;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            color: #666;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            white-space: nowrap;
        }

        /* --- 2. éŠæˆ²é é¢æ¨£å¼ --- */
        #game-screen {
            justify-content: flex-start;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            z-index: 10;
        }

        .stat-box {
            display: flex;
            align-items: center;
            font-weight: bold;
            font-size: 1.1rem;
        }
        .stat-icon { margin-right: 5px; font-size: 1.2rem; }

        .game-board-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 10px;
            overflow: hidden;
        }

        .grid {
            display: grid;
            gap: 2px;
            position: relative;
            /* ç”± JS å‹•æ…‹è¨ˆç®— columns */
        }

        .tile {
            background: white;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem; /* æœƒè¢« JS èª¿æ•´ */
            box-shadow: 0 2px 0 #e0e0e0;
            cursor: pointer;
            transition: transform 0.1s, background-color 0.1s;
            user-select: none;
        }

        .tile.selected {
            background: #ffeaa7;
            transform: scale(0.9);
            box-shadow: inset 0 0 0 2px #fdcb6e;
        }
        
        .tile.error {
            background: #ffcccc;
            animation: shake 0.3s;
        }

        .tile.empty {
            opacity: 0;
            pointer-events: none;
        }

        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }
        .path-line {
            stroke: var(--primary);
            stroke-width: 4;
            stroke-linecap: round;
            fill: none;
        }

        .game-footer {
            padding: 15px;
            display: flex;
            justify-content: space-around;
            background: white;
        }

        .btn {
            background: #eee;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1rem;
            font-weight: bold;
            color: #555;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn:active { transform: scale(0.95); }
        .btn-primary { background: var(--primary); color: white; }
        
        /* åœç”¨æŒ‰éˆ•æ¨£å¼ */
        .btn:disabled, .btn.disabled {
            background: #ccc;
            color: #888;
            cursor: not-allowed;
            transform: none;
        }

        /* --- å½ˆçª— (å‹åˆ©/å¤±æ•—/æ’è¡Œæ¦œ) --- */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal {
            background: white;
            width: 80%;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    </style>
</head>
<body>

    <div id="map-screen" class="screen active">
        <div class="map-header">
            <h1>ğŸ—ºï¸ å†’éšªåœ°åœ–</h1>
            <p>é»é¸é—œå¡é–‹å§‹æŒ‘æˆ°</p>
        </div>
        <div class="level-path" id="level-container">
            </div>
        <div style="text-align: center; margin-top: 20px;">
            <button class="btn" onclick="clearData()">âš ï¸ æ¸…é™¤ç´€éŒ„</button>
        </div>
    </div>

    <div id="game-screen" class="screen">
        <div class="game-header">
            <div class="stat-box" style="color: #e74c3c;">
                <span class="stat-icon">â¤ï¸</span> <span id="lives-display">3</span>
            </div>
            <div class="stat-box" style="color: #2980b9;">
                <span class="stat-icon">â±ï¸</span> <span id="time-display">0</span>s
            </div>
        </div>

        <div class="game-board-container" id="board-container">
            <svg id="svg-layer"></svg>
            <div class="grid" id="grid">
                </div>
        </div>

        <div class="game-footer">
            <button class="btn" onclick="exitGame()">é€€å‡º</button>
            <button class="btn btn-primary" id="btn-shuffle" onclick="shuffleGame()">ğŸ”€ æ´—ç‰Œ</button>
        </div>
    </div>

    <div class="modal-overlay" id="result-modal">
        <div class="modal">
            <h2 id="modal-title">TITLE</h2>
            <p id="modal-msg">Message</p>
            <button class="btn btn-primary" id="modal-btn" onclick="closeModal()">ç¢ºå®š</button>
        </div>
    </div>

    <script>
        // --- éŠæˆ²è¨­å®šèˆ‡è³‡æ–™ ---
        // å®šç¾©é—œå¡ï¼šrows(ç›´), cols(æ©«), iconTypes(åœ–æ¡ˆå¤šæ¨£æ€§)
        // æ‰‹æ©Ÿç‰ˆï¼šrows æ‡‰å¤§æ–¼ cols
        const levels = [
            { id: 1, r: 6, c: 4, types: 6 },  // 4x6 = 24æ ¼ (ç°¡å–®)
            { id: 2, r: 8, c: 5, types: 10 }, // 5x8 = 40æ ¼
            { id: 3, r: 9, c: 6, types: 12 }, // 6x9 = 54æ ¼
            { id: 4, r: 10, c: 6, types: 15 },// 6x10 = 60æ ¼ (è®Šé›£)
            { id: 5, r: 12, c: 6, types: 16 },// 6x12 = 72æ ¼ (æŒ‘æˆ°)
        ];

        const iconsAll = ['ğŸ','ğŸŒ','ğŸ‡','ğŸ‰','ğŸ’','ğŸ“','ğŸ','ğŸ¥','ğŸ¥‘','ğŸ†','ğŸŒ½','ğŸ¥•','ğŸ„','ğŸ¥œ','ğŸª','ğŸ©','ğŸ”','ğŸ•'];
        
        let userData = {
            unlockedLevel: 1,
            scores: {} // { 1: 20, 2: 45 } (levelId: seconds)
        };

        // éŠæˆ²ç‹€æ…‹
        let currentLevelConfig = null;
        let grid = [];
        let tilesDOM = [];
        let selected = null;
        let lives = 3;
        let time = 0;
        let timerInterval;
        let pairsLeft = 0;
        let isProcessing = false;
        
        // æ–°å¢ï¼šæ´—ç‰Œæ¬¡æ•¸æ§åˆ¶
        let shufflesLeft = 1;

        // --- åˆå§‹åŒ–ç³»çµ± ---
        
        function loadData() {
            const saved = localStorage.getItem('onet_mobile_data');
            if (saved) {
                userData = JSON.parse(saved);
            }
            renderMap();
        }

        function saveData() {
            localStorage.setItem('onet_mobile_data', JSON.stringify(userData));
        }

        function clearData() {
            if(confirm("ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰é€²åº¦å—ï¼Ÿ")){
                localStorage.removeItem('onet_mobile_data');
                location.reload();
            }
        }

        // --- åœ°åœ–ä»‹é¢ ---

        function renderMap() {
            const container = document.getElementById('level-container');
            container.innerHTML = '';

            levels.forEach(level => {
                const node = document.createElement('div');
                node.classList.add('level-node');
                
                // ç‹€æ…‹åˆ¤æ–·
                if (level.id <= userData.unlockedLevel) {
                    node.classList.add('unlocked');
                    node.onclick = () => startGame(level);
                    node.innerText = level.id;
                    
                    // å¦‚æœé€™é—œæœ‰ç©éï¼Œé¡¯ç¤ºç´€éŒ„
                    if (userData.scores[level.id]) {
                        const scoreTag = document.createElement('div');
                        scoreTag.classList.add('best-score');
                        scoreTag.innerText = `ğŸ‘‘ ${userData.scores[level.id]}s`;
                        node.appendChild(scoreTag);
                    }
                } else {
                    node.innerText = "ğŸ”’";
                    node.style.cursor = "default";
                    node.style.background = "#ddd";
                    node.style.color = "#aaa";
                }

                if (level.id === userData.unlockedLevel) {
                    node.classList.add('current');
                }

                container.appendChild(node);
            });
        }

        // --- éŠæˆ²é‚è¼¯ ---

        function startGame(levelConfig) {
            currentLevelConfig = levelConfig;
            
            // åˆ‡æ›ç•«é¢
            document.getElementById('map-screen').classList.remove('active');
            document.getElementById('game-screen').classList.add('active');
            
            // é‡ç½®æ•¸æ“š
            lives = 3;
            time = 0;
            selected = null;
            isProcessing = false;
            
            // é‡ç½®æ´—ç‰Œæ¬¡æ•¸ç‚º 1
            shufflesLeft = 1; 
            
            updateStatus();
            updateShuffleBtn(); // æ›´æ–°æ´—ç‰ŒæŒ‰éˆ•ç‹€æ…‹

            // ç”Ÿæˆåœ°åœ–
            initBoard(levelConfig);

            // å•Ÿå‹•è¨ˆæ™‚
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                time++;
                document.getElementById('time-display').innerText = time;
            }, 1000);
        }

        function exitGame() {
            clearInterval(timerInterval);
            document.getElementById('game-screen').classList.remove('active');
            document.getElementById('map-screen').classList.add('active');
            renderMap(); // é‡æ–°æ¸²æŸ“ä»¥æ›´æ–°ä»»ä½•è®Šå‹•
        }

        function updateStatus() {
            document.getElementById('lives-display').innerText = lives;
            document.getElementById('time-display').innerText = time;
        }
        
        // æ–°å¢ï¼šæ›´æ–°æ´—ç‰ŒæŒ‰éˆ• UI
        function updateShuffleBtn() {
            const btn = document.getElementById('btn-shuffle');
            btn.innerText = `ğŸ”€ æ´—ç‰Œ (${shufflesLeft})`;
            
            if (shufflesLeft > 0) {
                btn.disabled = false;
                btn.classList.remove('disabled');
            } else {
                btn.disabled = true;
                btn.classList.add('disabled');
            }
        }

        function initBoard(config) {
            const innerRows = config.r;
            const innerCols = config.c;
            const rows = innerRows + 2; // åŠ é‚Šæ¡†
            const cols = innerCols + 2;
            const totalPairs = (innerRows * innerCols) / 2;
            pairsLeft = totalPairs;

            // 1. é¸åœ–æ¡ˆ
            let usedIcons = iconsAll.slice(0, config.types);
            let deck = [];
            for (let i = 0; i < totalPairs; i++) {
                const icon = usedIcons[i % usedIcons.length];
                deck.push(icon, icon);
            }
            deck.sort(() => Math.random() - 0.5);

            // 2. å»ºç«‹ç¶²æ ¼è³‡æ–™ (padding = null)
            grid = [];
            for (let r = 0; r < rows; r++) {
                let row = [];
                for (let c = 0; c < cols; c++) {
                    if (r === 0 || r === rows - 1 || c === 0 || c === cols - 1) {
                        row.push(null);
                    } else {
                        row.push(deck.pop());
                    }
                }
                grid.push(row);
            }

            // 3. æ¸²æŸ“ DOM
            renderGridDOM(rows, cols);
        }

        function renderGridDOM(rows, cols) {
            const gridEl = document.getElementById('grid');
            gridEl.innerHTML = '';
            tilesDOM = [];

            // è¨ˆç®—åˆé©çš„æ–¹å¡Šå¤§å°
            // å¯¬åº¦é™åˆ¶ï¼šè¢å¹•å¯¬åº¦æ¸›å» padding (ç´„ 20px)
            const screenW = window.innerWidth - 20;
            const maxTileW = Math.floor(screenW / cols);
            // é«˜åº¦é™åˆ¶ï¼šè¢å¹•é«˜åº¦æ¸›å» header/footer (ç´„ 150px) é™¤ä»¥ rows
            const screenH = window.innerHeight - 150;
            const maxTileH = Math.floor(screenH / rows);
            
            const tileSize = Math.min(maxTileW, maxTileH, 60); // æœ€å¤§ä¸è¶…é 60px

            gridEl.style.gridTemplateColumns = `repeat(${cols}, ${tileSize}px)`;
            gridEl.style.fontSize = `${tileSize * 0.6}px`; // åœ–æ¡ˆéš¨æ–¹å¡Šç¸®æ”¾

            for (let r = 0; r < rows; r++) {
                let rowTiles = [];
                for (let c = 0; c < cols; c++) {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    tile.style.width = `${tileSize}px`;
                    tile.style.height = `${tileSize}px`;
                    
                    if (grid[r][c] === null) {
                        tile.classList.add('empty');
                    } else {
                        tile.innerText = grid[r][c];
                        tile.onclick = () => handleInput(r, c);
                    }
                    
                    gridEl.appendChild(tile);
                    rowTiles.push(tile);
                }
                tilesDOM.push(rowTiles);
            }
        }

        // --- æ ¸å¿ƒé‚è¼¯ ---

        function handleInput(r, c) {
            if (isProcessing || grid[r][c] === null) return;
            
            const currentTile = tilesDOM[r][c];

            // ç¬¬ä¸€æ¬¡é»é¸
            if (!selected) {
                selected = {r, c};
                currentTile.classList.add('selected');
                return;
            }

            // é»åŒä¸€å€‹ -> å–æ¶ˆ
            if (selected.r === r && selected.c === c) {
                selected = null;
                currentTile.classList.remove('selected');
                return;
            }

            // ç¬¬äºŒæ¬¡é»é¸ -> é–‹å§‹æ¯”å°
            const prevTile = tilesDOM[selected.r][selected.c];
            
            // 1. åœ–æ¡ˆä¸åŒ
            if (grid[selected.r][selected.c] !== grid[r][c]) {
                handleMistake(prevTile, currentTile);
                return;
            }

            // 2. åœ–æ¡ˆç›¸åŒï¼Œæª¢æŸ¥è·¯å¾‘
            const path = findPath(selected.r, selected.c, r, c);
            if (path) {
                // é…å°æˆåŠŸ
                isProcessing = true;
                drawPath(path);
                
                // å»¶é²æ¶ˆé™¤
                setTimeout(() => {
                    grid[selected.r][selected.c] = null;
                    grid[r][c] = null;
                    
                    prevTile.classList.remove('selected');
                    prevTile.classList.add('empty');
                    prevTile.innerText = '';
                    prevTile.onclick = null;

                    currentTile.classList.add('empty');
                    currentTile.innerText = '';
                    currentTile.onclick = null;

                    selected = null;
                    isProcessing = false;
                    pairsLeft--;

                    if (pairsLeft === 0) {
                        gameWin();
                    }
                }, 300);

            } else {
                // è·¯å¾‘ä¸é€š
                handleMistake(prevTile, currentTile);
            }
        }

        function handleMistake(tile1, tile2) {
            isProcessing = true;
            tile2.classList.add('error'); // ç´…è‰²éœ‡å‹•
            tile1.classList.add('error');
            
            lives--;
            updateStatus();

            setTimeout(() => {
                tile1.classList.remove('selected', 'error');
                tile2.classList.remove('error');
                selected = null;
                isProcessing = false;

                if (lives <= 0) {
                    gameOver();
                }
            }, 500);
        }

        // --- è·¯å¾‘æ¼”ç®—æ³• ---
        function findPath(r1, c1, r2, c2) {
            // ç›´ç·š
            if (checkLine(r1, c1, r2, c2)) return [{r:r1, c:c1}, {r:r2, c:c2}];
            // 1è½‰
            if (grid[r1][c2] === null && checkLine(r1, c1, r1, c2) && checkLine(r1, c2, r2, c2)) return [{r:r1, c:c1}, {r:r1, c:c2}, {r:r2, c:c2}];
            if (grid[r2][c1] === null && checkLine(r1, c1, r2, c1) && checkLine(r2, c1, r2, c2)) return [{r:r1, c:c1}, {r:r2, c:c1}, {r:r2, c:c2}];
            // 2è½‰
            const rows = grid.length;
            const cols = grid[0].length;
            for (let k = 0; k < cols; k++) {
                if (grid[r1][k] === null && checkLine(r1, c1, r1, k) && checkLine(r1, k, r2, k) && checkLine(r2, k, r2, c2) && grid[r2][k] === null) {
                    return [{r:r1, c:c1}, {r:r1, c:k}, {r:r2, c:k}, {r:r2, c:c2}];
                }
            }
            for (let k = 0; k < rows; k++) {
                if (grid[k][c1] === null && checkLine(r1, c1, k, c1) && checkLine(k, c1, k, c2) && checkLine(k, c2, r2, c2) && grid[k][c2] === null) {
                    return [{r:r1, c:c1}, {r:k, c:c1}, {r:k, c:c2}, {r:r2, c:c2}];
                }
                     color: #666;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            white-space: nowrap;
        }

        /* --- 2. éŠæˆ²é é¢æ¨£å¼ --- */
        #game-screen {
            justify-content: flex-start;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            z-index: 10;
        }

        .stat-box {
            display: flex;
            align-items: center;
            font-weight: bold;
            font-size: 1.1rem;
        }
        .stat-icon { margin-right: 5px; font-size: 1.2rem; }

        .game-board-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 10px;
            overflow: hidden;
        }

        .grid {
            display: grid;
            gap: 2px;
            position: relative;
            /* ç”± JS å‹•æ…‹è¨ˆç®— columns */
        }

        .tile {
            background: white;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem; /* æœƒè¢« JS èª¿æ•´ */
            box-shadow: 0 2px 0 #e0e0e0;
            cursor: pointer;
            transition: transform 0.1s, background-color 0.1s;
            user-select: none;
        }

        .tile.selected {
            background: #ffeaa7;
            transform: scale(0.9);
            box-shadow: inset 0 0 0 2px #fdcb6e;
        }
        
        .tile.error {
            background: #ffcccc;
            animation: shake 0.3s;
        }

        .tile.empty {
            opacity: 0;
            pointer-events: none;
        }

        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }
        .path-line {
            stroke: var(--primary);
            stroke-width: 4;
            stroke-linecap: round;
            fill: none;
        }

        .game-footer {
            padding: 15px;
            display: flex;
            justify-content: space-around;
            background: white;
        }

        .btn {
            background: #eee;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1rem;
            font-weight: bold;
            color: #555;
            cursor: pointer;
        }
        .btn:active { transform: scale(0.95); }
        .btn-primary { background: var(--primary); color: white; }

        /* --- å½ˆçª— (å‹åˆ©/å¤±æ•—/æ’è¡Œæ¦œ) --- */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .modal {
            background: white;
            width: 80%;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    </style>
</head>
<body>

    <div id="map-screen" class="screen active">
        <div class="map-header">
            <h1>ğŸ—ºï¸ å†’éšªåœ°åœ–</h1>
            <p>é»é¸é—œå¡é–‹å§‹æŒ‘æˆ°</p>
        </div>
        <div class="level-path" id="level-container">
            </div>
        <div style="text-align: center; margin-top: 20px;">
            <button class="btn" onclick="clearData()">âš ï¸ æ¸…é™¤ç´€éŒ„</button>
        </div>
    </div>

    <div id="game-screen" class="screen">
        <div class="game-header">
            <div class="stat-box" style="color: #e74c3c;">
                <span class="stat-icon">â¤ï¸</span> <span id="lives-display">3</span>
            </div>
            <div class="stat-box" style="color: #2980b9;">
                <span class="stat-icon">â±ï¸</span> <span id="time-display">0</span>s
            </div>
        </div>

        <div class="game-board-container" id="board-container">
            <svg id="svg-layer"></svg>
            <div class="grid" id="grid">
                </div>
        </div>

        <div class="game-footer">
            <button class="btn" onclick="exitGame()">é€€å‡º</button>
            <button class="btn btn-primary" onclick="shuffleGame()">ğŸ”€ æ´—ç‰Œ</button>
        </div>
    </div>

    <div class="modal-overlay" id="result-modal">
        <div class="modal">
            <h2 id="modal-title">TITLE</h2>
            <p id="modal-msg">Message</p>
            <button class="btn btn-primary" id="modal-btn" onclick="closeModal()">ç¢ºå®š</button>
        </div>
    </div>

    <script>
        // --- éŠæˆ²è¨­å®šèˆ‡è³‡æ–™ ---
        // å®šç¾©é—œå¡ï¼šrows(ç›´), cols(æ©«), iconTypes(åœ–æ¡ˆå¤šæ¨£æ€§)
        // æ‰‹æ©Ÿç‰ˆï¼šrows æ‡‰å¤§æ–¼ cols
        const levels = [
            { id: 1, r: 6, c: 4, types: 6 },  // 4x6 = 24æ ¼ (ç°¡å–®)
            { id: 2, r: 8, c: 5, types: 10 }, // 5x8 = 40æ ¼
            { id: 3, r: 9, c: 6, types: 12 }, // 6x9 = 54æ ¼
            { id: 4, r: 10, c: 6, types: 15 },// 6x10 = 60æ ¼ (è®Šé›£)
            { id: 5, r: 12, c: 6, types: 16 },// 6x12 = 72æ ¼ (æŒ‘æˆ°)
        ];

        const iconsAll = ['ğŸ','ğŸŒ','ğŸ‡','ğŸ‰','ğŸ’','ğŸ“','ğŸ','ğŸ¥','ğŸ¥‘','ğŸ†','ğŸŒ½','ğŸ¥•','ğŸ„','ğŸ¥œ','ğŸª','ğŸ©','ğŸ”','ğŸ•'];
        
        let userData = {
            unlockedLevel: 1,
            scores: {} // { 1: 20, 2: 45 } (levelId: seconds)
        };

        // éŠæˆ²ç‹€æ…‹
        let currentLevelConfig = null;
        let grid = [];
        let tilesDOM = [];
        let selected = null;
        let lives = 3;
        let time = 0;
        let timerInterval;
        let pairsLeft = 0;
        let isProcessing = false;

        // --- åˆå§‹åŒ–ç³»çµ± ---
        
        function loadData() {
            const saved = localStorage.getItem('onet_mobile_data');
            if (saved) {
                userData = JSON.parse(saved);
            }
            renderMap();
        }

        function saveData() {
            localStorage.setItem('onet_mobile_data', JSON.stringify(userData));
        }

        function clearData() {
            if(confirm("ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰é€²åº¦å—ï¼Ÿ")){
                localStorage.removeItem('onet_mobile_data');
                location.reload();
            }
        }

        // --- åœ°åœ–ä»‹é¢ ---

        function renderMap() {
            const container = document.getElementById('level-container');
            container.innerHTML = '';

            levels.forEach(level => {
                const node = document.createElement('div');
                node.classList.add('level-node');
                
                // ç‹€æ…‹åˆ¤æ–·
                if (level.id <= userData.unlockedLevel) {
                    node.classList.add('unlocked');
                    node.onclick = () => startGame(level);
                    node.innerText = level.id;
                    
                    // å¦‚æœé€™é—œæœ‰ç©éï¼Œé¡¯ç¤ºç´€éŒ„
                    if (userData.scores[level.id]) {
                        const scoreTag = document.createElement('div');
                        scoreTag.classList.add('best-score');
                        scoreTag.innerText = `ğŸ‘‘ ${userData.scores[level.id]}s`;
                        node.appendChild(scoreTag);
                    }
                } else {
                    node.innerText = "ğŸ”’";
                    node.style.cursor = "default";
                    node.style.background = "#ddd";
                    node.style.color = "#aaa";
                }

                if (level.id === userData.unlockedLevel) {
                    node.classList.add('current');
                }

                container.appendChild(node);
            });
        }

        // --- éŠæˆ²é‚è¼¯ ---

        function startGame(levelConfig) {
            currentLevelConfig = levelConfig;
            
            // åˆ‡æ›ç•«é¢
            document.getElementById('map-screen').classList.remove('active');
            document.getElementById('game-screen').classList.add('active');
            
            // é‡ç½®æ•¸æ“š
            lives = 3;
            time = 0;
            selected = null;
            isProcessing = false;
            updateStatus();

            // ç”Ÿæˆåœ°åœ–
            initBoard(levelConfig);

            // å•Ÿå‹•è¨ˆæ™‚
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                time++;
                document.getElementById('time-display').innerText = time;
            }, 1000);
        }

        function exitGame() {
            clearInterval(timerInterval);
            document.getElementById('game-screen').classList.remove('active');
            document.getElementById('map-screen').classList.add('active');
            renderMap(); // é‡æ–°æ¸²æŸ“ä»¥æ›´æ–°ä»»ä½•è®Šå‹•
        }

        function updateStatus() {
            document.getElementById('lives-display').innerText = lives;
            document.getElementById('time-display').innerText = time;
        }

        function initBoard(config) {
            const innerRows = config.r;
            const innerCols = config.c;
            const rows = innerRows + 2; // åŠ é‚Šæ¡†
            const cols = innerCols + 2;
            const totalPairs = (innerRows * innerCols) / 2;
            pairsLeft = totalPairs;

            // 1. é¸åœ–æ¡ˆ
            let usedIcons = iconsAll.slice(0, config.types);
            let deck = [];
            for (let i = 0; i < totalPairs; i++) {
                const icon = usedIcons[i % usedIcons.length];
                deck.push(icon, icon);
            }
            deck.sort(() => Math.random() - 0.5);

            // 2. å»ºç«‹ç¶²æ ¼è³‡æ–™ (padding = null)
            grid = [];
            for (let r = 0; r < rows; r++) {
                let row = [];
                for (let c = 0; c < cols; c++) {
                    if (r === 0 || r === rows - 1 || c === 0 || c === cols - 1) {
                        row.push(null);
                    } else {
                        row.push(deck.pop());
                    }
                }
                grid.push(row);
            }

            // 3. æ¸²æŸ“ DOM
            renderGridDOM(rows, cols);
        }

        function renderGridDOM(rows, cols) {
            const gridEl = document.getElementById('grid');
            gridEl.innerHTML = '';
            tilesDOM = [];

            // è¨ˆç®—åˆé©çš„æ–¹å¡Šå¤§å°
            // å¯¬åº¦é™åˆ¶ï¼šè¢å¹•å¯¬åº¦æ¸›å» padding (ç´„ 20px)
            const screenW = window.innerWidth - 20;
            const maxTileW = Math.floor(screenW / cols);
            // é«˜åº¦é™åˆ¶ï¼šè¢å¹•é«˜åº¦æ¸›å» header/footer (ç´„ 150px) é™¤ä»¥ rows
            const screenH = window.innerHeight - 150;
            const maxTileH = Math.floor(screenH / rows);
            
            const tileSize = Math.min(maxTileW, maxTileH, 60); // æœ€å¤§ä¸è¶…é 60px

            gridEl.style.gridTemplateColumns = `repeat(${cols}, ${tileSize}px)`;
            gridEl.style.fontSize = `${tileSize * 0.6}px`; // åœ–æ¡ˆéš¨æ–¹å¡Šç¸®æ”¾

            for (let r = 0; r < rows; r++) {
                let rowTiles = [];
                for (let c = 0; c < cols; c++) {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    tile.style.width = `${tileSize}px`;
                    tile.style.height = `${tileSize}px`;
                    
                    if (grid[r][c] === null) {
                        tile.classList.add('empty');
                    } else {
                        tile.innerText = grid[r][c];
                        tile.onclick = () => handleInput(r, c);
                    }
                    
                    gridEl.appendChild(tile);
                    rowTiles.push(tile);
                }
                tilesDOM.push(rowTiles);
            }
        }

        // --- æ ¸å¿ƒé‚è¼¯ (èˆ‡ä¹‹å‰é¡ä¼¼ï¼Œä½†åŠ å…¥éŒ¯èª¤åˆ¤å®š) ---

        function handleInput(r, c) {
            if (isProcessing || grid[r][c] === null) return;
            
            const currentTile = tilesDOM[r][c];

            // ç¬¬ä¸€æ¬¡é»é¸
            if (!selected) {
                selected = {r, c};
                currentTile.classList.add('selected');
                return;
            }

            // é»åŒä¸€å€‹ -> å–æ¶ˆ
            if (selected.r === r && selected.c === c) {
                selected = null;
                currentTile.classList.remove('selected');
                return;
            }

            // ç¬¬äºŒæ¬¡é»é¸ -> é–‹å§‹æ¯”å°
            const prevTile = tilesDOM[selected.r][selected.c];
            
            // 1. åœ–æ¡ˆä¸åŒ
            if (grid[selected.r][selected.c] !== grid[r][c]) {
                handleMistake(prevTile, currentTile);
                return;
            }

            // 2. åœ–æ¡ˆç›¸åŒï¼Œæª¢æŸ¥è·¯å¾‘
            const path = findPath(selected.r, selected.c, r, c);
            if (path) {
                // é…å°æˆåŠŸ
                isProcessing = true;
                drawPath(path);
                
                // å»¶é²æ¶ˆé™¤
                setTimeout(() => {
                    grid[selected.r][selected.c] = null;
                    grid[r][c] = null;
                    
                    prevTile.classList.remove('selected');
                    prevTile.classList.add('empty');
                    prevTile.innerText = '';
                    prevTile.onclick = null;

                    currentTile.classList.add('empty');
                    currentTile.innerText = '';
                    currentTile.onclick = null;

                    selected = null;
                    isProcessing = false;
                    pairsLeft--;

                    if (pairsLeft === 0) {
                        gameWin();
                    }
                }, 300);

            } else {
                // è·¯å¾‘ä¸é€š
                handleMistake(prevTile, currentTile);
            }
        }

        function handleMistake(tile1, tile2) {
            isProcessing = true;
            tile2.classList.add('error'); // ç´…è‰²éœ‡å‹•
            tile1.classList.add('error');
            
            lives--;
            updateStatus();

            setTimeout(() => {
                tile1.classList.remove('selected', 'error');
                tile2.classList.remove('error');
                selected = null;
                isProcessing = false;

                if (lives <= 0) {
                    gameOver();
                }
            }, 500);
        }

        // --- è·¯å¾‘æ¼”ç®—æ³• (ä¿æŒä¸è®Š) ---
        function findPath(r1, c1, r2, c2) {
            // ç›´ç·š
            if (checkLine(r1, c1, r2, c2)) return [{r:r1, c:c1}, {r:r2, c:c2}];
            // 1è½‰
            if (grid[r1][c2] === null && checkLine(r1, c1, r1, c2) && checkLine(r1, c2, r2, c2)) return [{r:r1, c:c1}, {r:r1, c:c2}, {r:r2, c:c2}];
            if (grid[r2][c1] === null && checkLine(r1, c1, r2, c1) && checkLine(r2, c1, r2, c2)) return [{r:r1, c:c1}, {r:r2, c:c1}, {r:r2, c:c2}];
            // 2è½‰
            const rows = grid.length;
            const cols = grid[0].length;
            for (let k = 0; k < cols; k++) {
                if (grid[r1][k] === null && checkLine(r1, c1, r1, k) && checkLine(r1, k, r2, k) && checkLine(r2, k, r2, c2) && grid[r2][k] === null) {
                    return [{r:r1, c:c1}, {r:r1, c:k}, {r:r2, c:k}, {r:r2, c:c2}];
                }
            }
            for (let k = 0; k < rows; k++) {
                if (grid[k][c1] === null && checkLine(r1, c1, k, c1) && checkLine(k, c1, k, c2) && checkLine(k, c2, r2, c2) && grid[k][c2] === null) {
                    return [{r:r1, c:c1}, {r:k, c:c1}, {r:k, c:c2}, {r:r2, c:c2}];
                }
            }
            return null;
        }

        function checkLine(r1, c1, r2, c2) {
            if (r1 === r2) {
                for (let c = Math.min(c1, c2) + 1; c < Math.max(c1, c2); c++) if (grid[r1][c] !== null) return false;
                return true;
            } else if (c1 === c2) {
                for (let r = Math.min(r1, r2) + 1; r < Math.max(r1, r2); r++) if (grid[r][c1] !== null) return false;
                return true;
            }
            return false;
        }

        // --- ç¹ªåœ–è¼”åŠ© ---
        function drawPath(points) {
            const svg = document.getElementById('svg-layer');
            svg.innerHTML = '';
            
            let d = "";
            points.forEach((p, i) => {
                const t = tilesDOM[p.r][p.c];
                // è¨ˆç®—ä¸­å¿ƒé» (ç›¸å°æ–¼ svg/container)
                const rect = t.getBoundingClientRect();
                const containerRect = document.getElementById('board-container').getBoundingClientRect();
                
                const x = rect.left - containerRect.left + rect.width / 2;
                const y = rect.top - containerRect.top + rect.height / 2;
                
                d += (i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
            });

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", d);
            path.classList.add("path-line");
            svg.appendChild(path);

            setTimeout(() => svg.innerHTML = '', 300);
        }

        function shuffleGame() {
            let currentIcons = [];
            const rows = grid.length;
            const cols = grid[0].length;
            
            for(let r=1; r<rows-1; r++) {
                for(let c=1; c<cols-1; c++) {
                    if(grid[r][c] !== null) currentIcons.push(grid[r][c]);
                }
            }
            currentIcons.sort(() => Math.random() - 0.5);
            
            let idx = 0;
            for(let r=1; r<rows-1; r++) {
                for(let c=1; c<cols-1; c++) {
                    if(grid[r][c] !== null) {
                        grid[r][c] = currentIcons[idx];
                        tilesDOM[r][c].innerText = currentIcons[idx];
                        tilesDOM[r][c].classList.remove('selected', 'error');
                        idx++;
                    }
                }
            }
            selected = null;
        }

        // --- çµç®—æµç¨‹ ---
        const modalEl = document.getElementById('result-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMsg = document.getElementById('modal-msg');
        const modalBtn = document.getElementById('modal-btn');

        function showModal(title, msg, btnText, callback) {
            modalTitle.innerText = title;
            modalMsg.innerText = msg;
            modalBtn.innerText = btnText;
            modalBtn.onclick = () => {
                modalEl.style.display = 'none';
                if(callback) callback();
            };
            modalEl.style.display = 'flex';
        }

        function gameWin() {
            clearInterval(timerInterval);
            
            // æ›´æ–°æœ€é«˜åˆ†
            const lvl = currentLevelConfig.id;
            let isNewRecord = false;
            if (!userData.scores[lvl] || time < userData.scores[lvl]) {
                userData.scores[lvl] = time;
                isNewRecord = true;
            }

            // è§£é–ä¸‹ä¸€é—œ
            if (lvl === userData.unlockedLevel && lvl < levels.length) {
                userData.unlockedLevel++;
            }
            saveData();

            let msg = `è€—æ™‚ï¼š${time}ç§’`;
            if (isNewRecord) msg += "\nğŸ† åˆ·æ–°ç´€éŒ„ï¼";
            
            showModal("ğŸ‰ éé—œæˆåŠŸï¼", msg, "å›åˆ°åœ°åœ–", () => {
                exitGame();
            });
        }

        function gameOver() {
            clearInterval(timerInterval);
            showModal("ğŸ’” æŒ‘æˆ°å¤±æ•—", "æ„›å¿ƒç”¨å…‰äº†ï¼Œå†æ¥å†å²ï¼", "é‡è©¦", () => {
                exitGame();
            });
        }

        // å•Ÿå‹•
        loadData();

    </script>
</body>
</html>

